# -*- coding: utf-8 -*-
"""Gradient Descent vs Simple Genetic Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sZ4WcFcckQmL7kWB7Z8AHsAzP5nV-KJq

# Gradient Descent vs Simple Genetic Algorithm

## Gradient Descent implementation
"""

import numpy as np
coeff = np.array([2.0, -2.0, 3.0, 1.0, -1.0, 8.0])

def grad_descent(co, x, lr, num_iters):
  for ii in range(num_iters):
    x -= lr * co
    print('candidate:'+ str(x), '  ',' value:' + str(np.sum(co*x)))

x = np.zeros(6)
grad_descent(coeff, x, 0.1, 12)

"""## Simple Genetic Algorithm implementation"""

import numpy as np
import numpy.random as npr
coeff = np.array([2.0, -2.0, 3.0, 1.0, -1.0, 8.0])
coeff_size = coeff.size    # size of chromosome for each candidate
candidates = 8     # 8 candidates per generations
pop_size = (candidates, coeff_size)

curr_pop = npr.uniform(low = -3.0, high = 3.0, size = pop_size) # generate random intial population
num_generations = 50
num_mating = 4

def mating_pool(pop, fitness, num_mat):
  parents = np.empty((num_mat, pop.shape[1])) # define parents with chromosomes of appropriate length
  for parent in range(num_mat):
    max_fitness = np.where(fitness == np.max(fitness)) # store index of parent with highest fitness
    parents[parent,:] = pop[max_fitness,:]
    fitness[max_fitness] = -1000000000000000 # remove this parent so the next best can be selected
  return parents

def crossover(parents, num_children):
  children = np.empty(num_children)
  crossover_point = 4
  for ii in range(num_children[0]):
    parent1 = ii % parents.shape[0]
    parent2 = (ii+1) % parents.shape[0]
    children[ii, 0:crossover_point] = parents[parent1, 0:crossover_point]
    children[ii, crossover_point:] = parents[parent2, crossover_point:]
  return children

def mutate(children_crossover):
  for ii in range(children_crossover.shape[0]):
    rand = npr.uniform(-1.0,1.0,1)
    idx = npr.randint(children_crossover.shape[1])
    children_crossover[ii, idx] += rand
  return children_crossover   


for generation in range(num_generations):
  lastgen = curr_pop
  fitness = -1 * (np.sum(curr_pop * coeff, axis = 1)) # calculate fitness of each candidate
  print('best value of generation: '+str(-1*np.max(fitness)))
  parents = mating_pool(curr_pop, fitness, num_mating)
  children_crossover = crossover(parents, num_children = (candidates-num_mating, coeff_size))
  children_mutation = mutate(children_crossover)
  
  curr_pop[0:num_mating,:] = parents # carry the best parents through to next generation
  curr_pop[num_mating:,:] = children_mutation # add the offspring to new population
  

print(lastgen)

print(np.sum(curr_pop * coeff, axis = 1)) # fitness values for the final population